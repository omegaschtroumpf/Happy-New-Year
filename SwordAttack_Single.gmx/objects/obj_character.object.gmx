<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize Variables

// Character constants
MOVEMENT_SPEED = 3;
KNOCKBACK = 5;
TARGET_ANGLE = 90;
TARGET_MAX_DISTANCE = 400;
FOCUS_RATE_THRESHOLD = 50;
FOCUS_MAX = 100;
FOCUS_REGEN = .78; // 14 / 30 // ~14 PER SECOND (orig 7/30)
FOCUS_REGEN_FAST = .86; // 1 / 3 20 PER SECOND (original 1/3)
FOCUS_REGEN_PENALTY = 90; // when focus &lt; 0, # steps regen is suspended
QUICKSTEP_SPEED_BASE = 15;
QUICKSTEP_FORWARD_MULTIPLIER = 1.75;
QUICKSTEP_BACK_MULTIPLIER = 1.5;
QUICKSTEP_SIDE_MULTIPLIER = 4 / 3;
QUICKSTEP_FRICTION_BASE = 1.5
QUICKSTEP_FRICTION_MULTIPLIER = 1.2;
QUICKSTEP_ATTACK_THRESHOLD = 20;
QUICKSTEP_COOLDOWN = 30;
QUICKSTEP_COLLISION_MULTIPLIER = .75;
QUICKSTEP_MUTUAL_COLLISION_FOCUS_BONUS = 10;
QUICKSTEP_SINGLE_COLLISION_FOCUS_BONUS = 30;
QUICKSTEP_SINGLE_COLLISION_FOCUS_PENALTY = 50;
QUICKSTEP_SPEED_THRESHOLD = 20;
QUICKSTEP_SHORT_STUN_DELAY = 10;
QUICKSTEP_LONG_STUN_DELAY = 30;
QUICKSTEP_FOCUS_COST = 40;
SWORD_LOCK_TIME_LIMIT = 90;
SWORD_LOCK_BUTTON_LEAD = 10;
BLOCK_MOVEMENT_MULTIPLIER = .5;
ATTACK_MOVEMENT_MULTIPLIER = .5;
POWER_ATTACK_MOVEMENT_MULTIPLIER = 2;
ATTACK_PUSH_MULTIPLIER = .25;
FIRST_ATTACK_CAN_ATTACK_DELAY = 1;
FIRST_ATTACK_CAN_MOVE_DELAY = 7;
FIRST_ATTACK_COMBO_DELAY = 5;
FIRST_ATTACK_FOCUS_COST = 40; //orginal 20
SUCCESSIVE_ATTACK_FOCUS_MODIFIER = 12;
SECOND_ATTACK_CAN_ATTACK_DELAY = 30;
SECOND_ATTACK_CAN_MOVE_DELAY = 30;
SECOND_ATTACK_COMBO_DELAY = 30;
SECOND_ATTACK_FOCUS_COST = 30;
ATTACK_PENALTY_CAN_ATTACK_DELAY = 12;
ATTACK_PENALTY_CAN_MOVE_DELAY = 12;
BLOCK_RAISE_DELAY = 5;
BLOCK_LOCK_DELAY = 12;
BLOCK_LOCK_EXTENSION = 8;
BLOCK_FOCUS_COST = 45;
PARRY_THRESHOLD = 4;
PARRIED_STUN_DELAY = 15;
PARRIED_SPEED = 15;
RESPAWN_DELAY = 10;
DAMAGE_DELAY = 15;
NORMAL_IMAGE = 0;
DAMAGE_IMAGE = 1;
BLOCKING_IMAGE = 2;
CHARACTER_KILLED_ROOM_SPEED = 15;
NORMAL_ROOM_SPEED = 30;

random_move = 0; // 1-29
killed = false;

// Sprite property assignments - won't be needed once we have custom sprites
image_xscale = 3;
image_yscale = 3;
image_speed = 0;
image_angle = direction;


// character state variables
character_health = 2; //currently just tracking player hits
character_focus_max = FOCUS_MAX; // 100 to start.  Could get hit and drop to 70.
character_focus = FOCUS_MAX; // this is for later
focus_regen = true; // can regenerate focus
can_move = true; // applies to motion and auto-target direction changes
can_target = true;
can_attack = true;
can_block = true;
can_quickstep = true;
quick_stepping = false;
quick_step_attack = false;
sword_lock = false;
sword_lock_button_count = 0;
unfocused = false; // set to true at completion of action that decremented focus to/below 0
stunned = false;
attack_combo = 0; // track the number of sequential attacks for correct animation
attack_penalty = false; //
block_held = false; // set to true when block button is pressed, false when block button is released
blocking = false; // set to true when block is raised
block_lock = false; // ensures the minimum block time
invincible = false; // this stays set for the greater of minimum block time, or the time that the player holds the block button beyond minimum block time
quickstep_collided = false;
soft_target = false;

/*
continue_attack = false;
follow_up_attack = false;
*/

// related objects
targetID = 0;
swordID = 0;
controlID = 0;
statsID = 0;
enemiesID = 0;
softTargetAngles = ds_list_create();


// player controller input variables
deviceID = -1; // this is set by the room or when character dies and replacement is made
x_axisL = 0;
y_axisL = 0;
x_axisR = 0;
y_axisR = 0;
shoulder_r_pressed = 0;
shoulder_l_pressed = 0;
shoulder_l_released = 0;
dash_button_pressed = 0;
target_button_pressed = 0;
target_cancel_button_pressed = 0;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy Related Objects

if (swordID) {
with (swordID) instance_destroy();
}

ds_list_destroy(softTargetAngles);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// blank
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="9">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Focus Regen Reset

focus_regen = true;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="8">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Recover from Stun
stunned = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset Quickstep
if (!blocking) can_quickstep = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="6">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Character Death

// Reset room speed to normal
rm_arena.room_speed = NORMAL_ROOM_SPEED;
characterDeath();
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Minimum Block Time
block_lock = false;
if (!block_held) &amp;&amp; (character_health &gt; 0){ //added death check
    if (blocking) {
        can_attack = true;
        can_block = true;
        can_quickstep = true;
        blocking = false;
        invincible = false;
        image_index = NORMAL_IMAGE;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Block Raise Delay
if (image_index != BLOCKING_IMAGE) image_index = BLOCKING_IMAGE;
blocking = true;
invincible = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Attack Combo Reset
attack_combo = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement Reset After Attack
can_move = true;
can_target = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Recover From Being Hit
image_index = NORMAL_IMAGE;
if (!blocking) {
    invincible = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Attack Timer Reset
can_attack = true;
can_block = true;
attack_penalty = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input, Movement, Attacking, Blocking

// Regenerate Focus
if (focus_regen) {
    if (character_focus &lt; 0) {
        character_focus = 0;
        focus_regen = false;
        alarm[9] = FOCUS_REGEN_PENALTY;
        //break block if stamina is depleted
        block_lock = false;
        block_held = false;
    }
    else if (character_focus &lt; character_focus_max) {
        if (character_focus &lt; FOCUS_RATE_THRESHOLD) character_focus += FOCUS_REGEN_FAST;
        else character_focus += FOCUS_REGEN;
    }
}

// if quickstepping increase friction
if (speed &gt; 0) {
    friction *= QUICKSTEP_FRICTION_MULTIPLIER;
    if (speed &lt; QUICKSTEP_ATTACK_THRESHOLD &amp;&amp; !quick_step_attack) {
        can_attack = true;
    }
}
else {
    if (quick_stepping &amp;&amp; !swordID) {
        quick_stepping = false;
        quickstep_collided = false;
        can_move = true;
        can_block = true;
    }
}


if (!stunned || sword_lock) {
    getCharacterInput(id);
}

if (!stunned) {
    if (can_target &amp;&amp; !swordID) {
        // if right stick input without cancelling target, point that way as a starting point for soft targeting
        if ((x_axisR != 0 || y_axisR != 0) &amp;&amp; !target_cancel_button_pressed) {
            soft_target = true;
            targetID = 0;
            image_angle = point_direction(0, 0, x_axisR, y_axisR);
        }
        if (target_button_pressed) {
            soft_target = true;
            targetID = 0;
        }
        if (target_cancel_button_pressed) {
            soft_target = false;
            targetID = 0;
        }
        if (soft_target) {
            // clear out angles list in case there's anything there.  we'll populate it here and potentially refer to it when attacking
            ds_list_clear(softTargetAngles);
            // look for enemies and calculate a new image_angle
            // go through the enemies' positions and see if they are in my line of sight
            num = ds_list_size(enemiesID);
            vector_x = 0;
            vector_y = 0;
            see_enemies = false;
            for (i = 0; i &lt; num; i++) {
                enemy = ds_list_find_value(enemiesID, i);
                enemy_distance = point_distance(x, y, enemy.x, enemy.y);
                // only do more calculation with this enemy if he is in range
                if (enemy_distance &lt;= TARGET_MAX_DISTANCE) {
                    enemy_direction = point_direction(x, y, enemy.x, enemy.y);
                    ds_list_add(softTargetAngles, enemy_direction);
                    angle_diff = angle_difference(image_angle, enemy_direction);
                    if ((angle_diff &lt; TARGET_ANGLE / 2) &amp;&amp; angle_diff &gt; (TARGET_ANGLE / -2)) {
                        // in my line of sight, add to my vector calculations
                        see_enemies = true;
                        // distance to enemy will weight the vectoring, the farther away, the lower the influence an enemy has on targeting
                        // enemy.x - x because I want to point from me at relative 0,0 towards enemy
                        vector_x += (enemy.x - x) / sqr(sqr(enemy_distance));
                        vector_y += (enemy.y - y) / sqr(sqr(enemy_distance));
                    }
                }
            }
            // if I saw enemies, adjust my angle to face them.  If not, I'll keep my angle from right stick
            if (see_enemies) {
                // now I have a vector for the weighted direction towards enemies.
                image_angle = point_direction(0, 0, vector_x, vector_y);
            }
            else {
                soft_target = false;
            }
        }
        // If I have a specific enemy target, just look at him
        else if (targetID) {            
            image_angle = point_direction(x, y, targetID.x,targetID.y);
        }
        // I aint got no target
        else {
            // what the hell direction am I moving in then?
            if (x_axisL != 0 || y_axisL != 0) image_angle = point_direction(0, 0, x_axisL, y_axisL);
        }
    }
    
    // player attacking
    if (shoulder_r_pressed) {
        if (swordID = 0 &amp;&amp; !block_held &amp;&amp; !block_lock) {
            if (can_attack &amp;&amp; character_focus &gt; 0) {
                if (quick_stepping) quick_step_attack = true;
                can_attack = false;
                can_block = false;
                can_move = false;
                can_target = false;
                //var attack_speed = character_focus / 100 + .2;//minor tweaks for feel
                //if (attack_speed &lt; .7) attack_speed = .7;
                character_focus -= (FIRST_ATTACK_FOCUS_COST + (attack_combo * SUCCESSIVE_ATTACK_FOCUS_MODIFIER))
                swordID = instance_create(x, y, obj_charactersword); // create a sword and keep its ID to ignore collisions
                swordID.attack_speed = 1; //attack_speed;
                //swordID.image_speed *= attack_speed;
                // set sword parentID so it can destroy itself and clear its parent's swordID;
                swordID.parentID = id;
                attack_combo++;
                
                swordID.image_xscale = 3;
                if (attack_combo % 2 == 1) {
                    swordID.image_yscale = 3;
                }
                else {
                    swordID.image_yscale = -3;
                }
                // if we are soft targeting and have directional input, direct the attack
                // toward the soft-targeted enemy whose angle is closest to input angle
                if (soft_target &amp;&amp; (x_axisL != 0 || y_axisL != 0)){
                    stick_angle = point_direction(0, 0, x_axisL, y_axisL);
                    num = ds_list_size(softTargetAngles);
                    smallest_angle_diff = 181; // angle_difference() returns a value -180..180
                    new_angle = 0; // This will change.  if we are soft_targeting, we can assume at least one enemy in view
                    for (i = 0; i &lt; num; i++) {
                        target_angle = ds_list_find_value(softTargetAngles, i);
                        angle_diff = abs(angle_difference(stick_angle, target_angle));
                        if (angle_diff &lt; smallest_angle_diff) {
                            smallest_angle_diff = angle_diff;
                            new_angle = target_angle;
                        }
                    }
                    image_angle = new_angle;
                }    
                swordID.image_angle = image_angle;
            }
            else {
                if (!attack_penalty) {
                    attack_penalty = true;
                    alarm[0] += ATTACK_PENALTY_CAN_ATTACK_DELAY; // extend time to reset can_attack.
                    alarm[2] += ATTACK_PENALTY_CAN_MOVE_DELAY; // still can't move
                    // alarm[3] will not be reset.  Bad timing misses chance to combo
                }
            }
        }
    }  
    
    // player moving
    if (can_move) {
    
        if (can_quickstep &amp;&amp; dash_button_pressed &amp;&amp; character_focus &gt; 0) {
            // do we have quickstep input?
            if (abs(x_axisL) &gt; .25 || abs(y_axisL) &gt; .25) {
                if (character_focus &gt;= QUICKSTEP_FOCUS_COST + 1) {
                    var stick_dir = point_direction(0, 0, x_axisL, y_axisL);
                    // what is the difference from character direction to input direction
                    var calc_dir = (image_angle - (stick_dir % 360)) * -1;
                    // for 4 directions, we have ranges of 90 degrees
                    // since angle 0 should be in the center of a range, we add 1/2 the range
                    //calc_dir += 45;
                    if (calc_dir &lt; 0) calc_dir += 360;
                    calc_dir = calc_dir % 360;
                    // calc_dir will be 0 if within 30 degrees either way
                    if (calc_dir &lt;= 30 || calc_dir &gt;= 330) calc_dir = 0;
                    // calc_dir will be 180 if within 30 degrees either way
                    if (calc_dir &gt;= 150 &amp;&amp; calc_dir &lt;= 210) calc_dir = 180;
                    
                    // now we know the direction, but we need the magnitude for that direction
                    var x_mag = 0;
                    var y_mag = 0;
                    
                    if (calc_dir &lt; 90 || calc_dir &gt; 270) x_mag = abs(dcos(calc_dir)) * QUICKSTEP_FORWARD_MULTIPLIER;
                    else x_mag = abs(dcos(calc_dir)) * QUICKSTEP_BACK_MULTIPLIER;
                    y_mag = abs(dsin(calc_dir)) * QUICKSTEP_SIDE_MULTIPLIER;
                    // now we have component magnitudes what is the result?
                    var calc_mag = point_distance(0,0,x_mag, y_mag);
                    // now we have a direction and a magnitude for movement in relation to image_direction
                    motion_set((image_angle + calc_dir), QUICKSTEP_SPEED_BASE * calc_mag);
                    // set starting friction and then each step it will increase
                    friction = QUICKSTEP_FRICTION_BASE;
                    quick_stepping = true;
                    can_quickstep = false;
                    can_move = false;
                    can_attack = false;
                    can_block = false;
                    alarm[7] = QUICKSTEP_COOLDOWN;
                    character_focus -= QUICKSTEP_FOCUS_COST;
                    audio_play_sound(snd_dash, 1, false);
                }
            }
        } // end if (can_quickstep)
        
        // not quickstepping
        if (block_lock || block_held) {
            var new_x = x + x_axisL * MOVEMENT_SPEED * BLOCK_MOVEMENT_MULTIPLIER;
            var new_y = y + y_axisL * MOVEMENT_SPEED * BLOCK_MOVEMENT_MULTIPLIER;
        }
        else {
            var new_x = x + x_axisL * MOVEMENT_SPEED;
            var new_y = y + y_axisL * MOVEMENT_SPEED;
        }
        
        if (place_empty(new_x, new_y)) {
            x = new_x;
            y = new_y;
        } else if (place_empty(new_x, y)) x = new_x;
        else if (place_empty(x, new_y)) y = new_y;   
        
    }
    
    // player and sword moving
    if (swordID) {
        // advance to target while attacking as long as not quickstepping
        if(!quick_step_attack) {
            var x_adj;
            var y_adj;
            if (swordID.hit_blocked) {
                // both this object and the target would move back at half speed
                x_adj = dcos(image_angle - 180) * MOVEMENT_SPEED * ATTACK_MOVEMENT_MULTIPLIER;
                y_adj = dsin(image_angle - 180) * MOVEMENT_SPEED * ATTACK_MOVEMENT_MULTIPLIER;
                
                // collision detection for target
                
                // movement if no collision
                targetID.x -= x_adj;
                targetID.y += y_adj;
                
                // collision detection for me backing up
                
                // movement if no collision
                x += x_adj;
                y -= y_adj;
            }
            else {
                // free swing or hitting target
                var mult = swordID.speed_multiplier;
                x_adj = dcos(image_angle) * mult * MOVEMENT_SPEED;
                y_adj = dsin(image_angle) * mult * MOVEMENT_SPEED;
                // if collision with opponent
                if (place_meeting(x + x_adj, y - y_adj, targetID)) {
                    // if opponent can move back, push at half speed
                    x_adj *= ATTACK_PUSH_MULTIPLIER;
                    y_adj *= ATTACK_PUSH_MULTIPLIER;
                    with (targetID) {
                        // but only if space behind him is open
                        if (place_free(x + x_adj, y - y_adj)) {
                            // push him back!
                            x += x_adj;
                            y -= y_adj;
                        }
                        else {
                            // no one will move
                            x_adj = 0;
                            y_adj = 0;
                        }
                    }
                }
                x += x_adj;
                y -= y_adj;
            }
        }
        // always adjust sword position to player position
        swordID.x = x;
        swordID.y = y;
        swordID.image_angle = image_angle;
    }
    
    // player blocking
    if (shoulder_l_pressed) {
        if (can_block) {
            can_attack = false;
            can_block = false;
            can_quickstep = false;
            block_held = true;
            block_lock = true;
            alarm[4] = BLOCK_RAISE_DELAY;
            alarm[5] = BLOCK_LOCK_DELAY;
        }
        else if (block_lock) {
            block_held = true;
        }
    }
    
    if (shoulder_l_released) {
        block_held = false;
        if (!block_lock) {
            can_attack = true;
            blocking = false;
            can_block = true;
            // only enable quickstep if the timer is not set
            if (alarm[7] == -1) can_quickstep = true;
            invincible = false;
            image_index = NORMAL_IMAGE;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_charactersword">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle sword collision
// make sure it's not my sword
if (other.id != swordID) {
    if (!invincible) {
        if (alarm[4] &gt;= BLOCK_RAISE_DELAY - PARRY_THRESHOLD) {
            // successful parry
            audio_play_sound(snd_parry, 100, false) 
            attackerID = other.parentID
            // pushback attacker
            with (attackerID) {
                quick_stepping = true;
                // stunned
                stunned = true;
                alarm[8] = PARRIED_STUN_DELAY;
                
                blocking = false;
                block_lock = false;
                block_held = false;
                invincible = false;
                direction = image_angle - 180;
                speed = PARRIED_SPEED;
                friction = QUICKSTEP_FRICTION_BASE;
                // decrease opponent's stamina
                character_focus -= 20;
                // disassociate attacker's sword
                swordID = 0;
            }
            // destroy opponent sword
            with (other) instance_destroy();
    
            // increase my stamina
            character_focus += 20;
            
            // reset block-related states
            block_held = false;
            block_lock = false;
            can_attack = true;
            blocking = false;
            can_block = true;
            if (alarm[7] == -1) can_quickstep = true;
            invincible = false;
            image_index = NORMAL_IMAGE;
            // clear block-related alarms
            alarm[4] = -1;
            alarm[5] = -1;
        }
        else {
            // lose my sword
            if (swordID) {
                with (swordID) instance_destroy();
                swordID = 0;
            }
            
            // knockback
            x += dcos(targetID.direction) * KNOCKBACK;
            y -= dsin(targetID.direction) * KNOCKBACK;
            character_health--;
            image_index = DAMAGE_IMAGE;
            invincible = true;
            if (character_health == 0) {
                // dead.  freeze and set a timer for cleanup event
                can_move = false;
                can_attack = false;
                alarm[4] = -1;//don't be shielding
                alarm[5] = -1;
                var i;
                for (i = 0; i &lt; 12; i++){
                    alarm[i] = -1;
                }
                alarm[6] = RESPAWN_DELAY;
                // for fun, slow down room speed
                rm_arena.room_speed = CHARACTER_KILLED_ROOM_SPEED;
            }
            else alarm[1] = DAMAGE_DELAY;
            // sound when hit
            audio_play_sound(snd_hit, 1, false);
        }
    }
    else {
        // hit blocked?
        if (blocking &amp;&amp; other.hit_blocked != true) {
            other.hit_blocked = true;
            character_focus -= BLOCK_FOCUS_COST;
            audio_play_sound(snd_block, 1, false);
        }
        // ensure block lock
        if (alarm[5] &lt; BLOCK_LOCK_EXTENSION) {
            block_lock = true;
            alarm[5] = BLOCK_LOCK_EXTENSION;
        } 
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_character">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle Quickstep Collisions

if (quick_stepping &amp;&amp; !quickstep_collided) {
    var lock_swords = false;

    // get out of collision
    x = xprevious;
    y = yprevious;
    other.x = other.xprevious;
    other.y = other.yprevious;

    // at least one of us is quickstepping, now we are both effectively quickstepping.
    if (!other.quick_stepping) {
        stunned = true;
        alarm[8] = QUICKSTEP_SHORT_STUN_DELAY;
        character_focus += QUICKSTEP_SINGLE_COLLISION_FOCUS_BONUS;
        if (speed &gt;= QUICKSTEP_SPEED_THRESHOLD) other.alarm[8] = QUICKSTEP_LONG_STUN_DELAY;
        else other.alarm[8] = QUICKSTEP_SHORT_STUN_DELAY;
        with (other) {
            stunned = true;
            blocking = false;
            block_lock = false;
            block_held = false;
            invincible = false;
            image_index = NORMAL_IMAGE;
            character_focus -= QUICKSTEP_SINGLE_COLLISION_FOCUS_PENALTY;
        }
    }
    else {
        character_focus += QUICKSTEP_MUTUAL_COLLISION_FOCUS_BONUS;
        other.character_focus += QUICKSTEP_MUTUAL_COLLISION_FOCUS_BONUS;
        // both are quickstepping do we recoil or lock swords?
        if (speed &gt;= QUICKSTEP_SPEED_THRESHOLD &amp;&amp; other.speed &gt;= QUICKSTEP_SPEED_THRESHOLD) lock_swords = true;
        else {
            stunned = true;
            alarm[8] = QUICKSTEP_SHORT_STUN_DELAY;
            other.stunned = true;
            other.alarm[8] = QUICKSTEP_SHORT_STUN_DELAY;
        }
    }
    
    if (lock_swords) {
        
        sword_lock = true;
        sword_lock_button_count = 0;
        controlID.alarm[0]  = SWORD_LOCK_TIME_LIMIT;
        other.sword_lock = true;
        other.sword_lock_button_count = 0;
        

        // move characters into locked swords position
        // find distance between the characters
        var dist = point_distance(x, y, other.x, other.y);
        // what portion of the distance belongs to this player
        var tot_speed = speed + other.speed;
        dist = dist * speed / tot_speed;
        dist -= (sprite_height / 2);
        x += dist * dcos(direction);
        y -= dist * dsin(direction);
        speed = 0;
        
        // move the other along this direction as well, but offset from this object
        dist = other.sprite_height;
        other.x = x + dist * dcos(direction);
        other.y = y - dist * dsin(direction);
        other.speed = 0;
        
        // for now I'll just stun both characters will remove after sword-lock dynamic is done
        stunned = true;
        other.stunned = true;

    }
    else {
        // take the higher of the two speeds and use it as the new speed for both characters to bounce
        var high_speed = speed;
        var high_speed_direction = direction;
        var high_speed_friction = friction;
        if (other.speed &gt; high_speed) {
            high_speed = other.speed;
            direction = other.direction;
            other.direction -= 180;
            high_speed_friction = other.friction;
        }
        else {
            other.direction = direction;
            direction -= 180;
        }
        
        high_speed = high_speed * QUICKSTEP_COLLISION_MULTIPLIER;
        speed = high_speed;
        other.speed = high_speed;
        friction = high_speed_friction;
        other.friction = high_speed_friction;
    }
    

    other.quickstep_collided = true;
    quickstep_collided = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>24,24</point>
  </PhysicsShapePoints>
</object>
