<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_hard</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize Variables

// Character constants
MOVEMENT_SPEED = 3;
KNOCKBACK = 5;
TARGET_ANGLE = 90;
TARGET_MAX_DISTANCE = 400;
FOCUS_RATE_THRESHOLD = 50;
FOCUS_MAX = 100;
FOCUS_REGEN = .78; // 14 / 30 // ~14 PER SECOND (orig 7/30)
FOCUS_REGEN_FAST = .86; // 1 / 3 20 PER SECOND (original 1/3)
FOCUS_REGEN_PENALTY = 90; // when focus &lt; 0, # steps regen is suspended
QUICKSTEP_SPEED_BASE = 15;
QUICKSTEP_FORWARD_MULTIPLIER = 1.75;
QUICKSTEP_BACK_MULTIPLIER = 1.5;
QUICKSTEP_SIDE_MULTIPLIER = 4 / 3;
QUICKSTEP_FRICTION_BASE = 1.5
QUICKSTEP_FRICTION_MULTIPLIER = 1.2;
QUICKSTEP_ATTACK_THRESHOLD = 20;
QUICKSTEP_COOLDOWN = 30;
QUICKSTEP_COLLISION_MULTIPLIER = .75;
QUICKSTEP_MUTUAL_COLLISION_FOCUS_BONUS = 10;
QUICKSTEP_SINGLE_COLLISION_FOCUS_BONUS = 30;
QUICKSTEP_SINGLE_COLLISION_FOCUS_PENALTY = 50;
QUICKSTEP_SPEED_THRESHOLD = 20;
QUICKSTEP_SHORT_STUN_DELAY = 10;
QUICKSTEP_LONG_STUN_DELAY = 30;
QUICKSTEP_FOCUS_COST = 40;
SWORD_LOCK_TIME_LIMIT = 90;
SWORD_LOCK_BUTTON_LEAD = 10;
BLOCK_MOVEMENT_MULTIPLIER = .5;
ATTACK_MOVEMENT_MULTIPLIER = .5;
POWER_ATTACK_MOVEMENT_MULTIPLIER = 2;
ATTACK_PUSH_MULTIPLIER = .25;
FIRST_ATTACK_CAN_ATTACK_DELAY = 12;
FIRST_ATTACK_CAN_MOVE_DELAY = 15;
FIRST_ATTACK_COMBO_DELAY = 15;
FIRST_ATTACK_FOCUS_COST = 40; //orginal 20
SUCCESSIVE_ATTACK_FOCUS_MODIFIER = 12;
SECOND_ATTACK_CAN_ATTACK_DELAY = 30;
SECOND_ATTACK_CAN_MOVE_DELAY = 30;
SECOND_ATTACK_COMBO_DELAY = 30;
SECOND_ATTACK_FOCUS_COST = 30;
ATTACK_PENALTY_CAN_ATTACK_DELAY = 12;
ATTACK_PENALTY_CAN_MOVE_DELAY = 12;
BLOCK_RAISE_DELAY = 5;
BLOCK_LOCK_DELAY = 12;
BLOCK_LOCK_EXTENSION = 8;
BLOCK_FOCUS_COST = 45;
PARRY_THRESHOLD = 4;
PARRIED_STUN_DELAY = 15;
PARRIED_SPEED = 15;
RESPAWN_DELAY = 10;
DAMAGE_DELAY = 15;
NORMAL_IMAGE = 0;
DAMAGE_IMAGE = 1;
BLOCKING_IMAGE = 2;
CHARACTER_KILLED_ROOM_SPEED = 15;
NORMAL_ROOM_SPEED = 30;

random_move = 0; // 1-29
killed = false;

// Sprite property assignments - won't be needed once we have custom sprites
image_xscale = 3;
image_yscale = 3;
image_speed = 0;
image_angle = direction;


// character state variables
character_health = 2; //currently just tracking player hits
character_focus_max = FOCUS_MAX; // 100 to start.  Could get hit and drop to 70.
character_focus = FOCUS_MAX; // this is for later
focus_regen = true; // can regenerate focus
can_move = true; // applies to motion and auto-target direction changes
can_target = true;
can_attack = true;
can_block = true;
can_quickstep = true;
quick_stepping = false;
quick_step_attack = false;
sword_lock = false;
sword_lock_button_count = 0;
unfocused = false; // set to true at completion of action that decremented focus to/below 0
stunned = false;
attack_combo = 0; // track the number of sequential attacks for correct animation
attack_penalty = false; //
block_held = false; // set to true when block button is pressed, false when block button is released
blocking = false; // set to true when block is raised
block_lock = false; // ensures the minimum block time
invincible = false; // this stays set for the greater of minimum block time, or the time that the player holds the block button beyond minimum block time
quickstep_collided = false;
soft_target = false;

/*
continue_attack = false;
follow_up_attack = false;
*/

// related objects
targetID = 0;
swordID = 0;
controlID = 0;
statsID = 0;
enemiesID = 0;
softTargetAngles = ds_list_create();


// player controller input variables
deviceID = -1; // this is set by the room or when character dies and replacement is made
x_axisL = 0;
y_axisL = 0;
x_axisR = 0;
y_axisR = 0;
shoulder_r_pressed = 0;
shoulder_l_pressed = 0;
shoulder_l_released = 0;
dash_button_pressed = 0;
target_button_pressed = 0;
target_cancel_button_pressed = 0;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy Related Objects

if (swordID) {
with (swordID) instance_destroy();
}

ds_list_destroy(softTargetAngles);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="9">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Focus Regen Reset

focus_regen = true;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="8">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Recover from Stun
stunned = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset Quickstep
if (!blocking) can_quickstep = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="6">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Character Death

// Reset room speed to normal
rm_arena.room_speed = NORMAL_ROOM_SPEED;


// later will raise an event so the controller can handle what happens, but for now
newID = instance_create(random(room_width), random(room_height), object_index);
// set target and device for new object
newID.targetID = targetID;
newID.deviceID = deviceID;
newID.controlID = controlID;
newID.statsID = statsID;

// set new instance to be old instance's target's target
targetID.targetID = newID;

if (controlID.player1 == id) controlID.player1 = newID;
else if (controlID.player2 == id) controlID.player2 = newID;

if (statsID.player1 == id) statsID.player1 = newID;
else if (statsID.player2 == id) statsID.player2 = newID;

instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Minimum Block Time
block_lock = false;
if (!block_held) &amp;&amp; (character_health &gt; 0){ //added death check
    if (blocking) {
        can_attack = true;
        can_block = true;
        can_quickstep = true;
        blocking = false;
        invincible = false;
        image_index = NORMAL_IMAGE;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Block Raise Delay
if (image_index != BLOCKING_IMAGE) image_index = BLOCKING_IMAGE;
blocking = true;
invincible = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Attack Combo Reset
attack_combo = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement Reset After Attack
can_move = true;
can_target = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Recover From Being Hit
image_index = NORMAL_IMAGE;
if (!blocking) {
    invincible = false;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Attack Timer Reset
can_attack = true;
can_block = true;
attack_penalty = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input, Movement, Attacking, Blocking

// Regenerate Focus
if (focus_regen) {
    if (character_focus &lt; 0) {
        character_focus = 0;
        focus_regen = false;
        alarm[9] = FOCUS_REGEN_PENALTY;
    }
    else if (character_focus &lt; character_focus_max) {
        if (character_focus &lt; FOCUS_RATE_THRESHOLD) character_focus += FOCUS_REGEN_FAST;
        else character_focus += FOCUS_REGEN;
    }
}

// if quickstepping increase friction
if (speed &gt; 0) {
    friction *= QUICKSTEP_FRICTION_MULTIPLIER;
    if (speed &lt; QUICKSTEP_ATTACK_THRESHOLD &amp;&amp; !quick_step_attack) {
        can_attack = true;
    }
}
else {
    if (quick_stepping &amp;&amp; !swordID) {
        quick_stepping = false;
        quickstep_collided = false;
        can_move = true;
        can_block = true;
    }
}


if (!stunned || sword_lock) {

    // player input
    // left stick input
    x_axisL = gamepad_axis_value(deviceID, gp_axislh); // -1 .. 1
    y_axisL = gamepad_axis_value(deviceID, gp_axislv);
    x_axisR = gamepad_axis_value(deviceID, gp_axisrh);
    y_axisR = gamepad_axis_value(deviceID, gp_axisrv);
    
    // slash button - Right button
    shoulder_r_pressed = gamepad_button_check_pressed(deviceID, gp_shoulderr);
    
    // blcok button - Left button
    shoulder_l_pressed = gamepad_button_check_pressed(deviceID, gp_shoulderl);
    shoulder_l_released = gamepad_button_check_released(deviceID, gp_shoulderl);
    
    // dash button - XBOX A Button
    dash_button_pressed = gamepad_button_check_pressed(deviceID, gp_face1);
}

if (!stunned) {

    if (can_target) {
        image_angle = point_direction(x,y,targetID.x,targetID.y);
    }
    
    // player attacking
    if (shoulder_r_pressed) {
        if (swordID = 0 &amp;&amp; !block_held &amp;&amp; !block_lock) {
            if (can_attack &amp;&amp; character_focus &gt; 0) {
                if (quick_stepping) quick_step_attack = true;
                can_attack = false;
                can_block = false;
                can_move = false;
                can_target = false;
                var attack_speed = character_focus / 100 + .2;//minor tweaks for feel
                if (attack_speed &lt; .7) attack_speed = .7;
                character_focus -= (FIRST_ATTACK_FOCUS_COST + (attack_combo * SUCCESSIVE_ATTACK_FOCUS_MODIFIER))
                swordID = instance_create(x, y, obj_charactersword); // create a sword and keep its ID to ignore collisions
                swordID.attack_speed = attack_speed;
                swordID.image_speed *= attack_speed;
                /*
                Reference an object with it's object ID
                This next line translates to:
                Store this object's (character's) object ID in the parentID field
                of the object identified by swordID.
                That way, when the sword is done doing its thing, it can destroy itself and clear
                its parentID.swordID to 0;
                */
                swordID.parentID = id;
                attack_combo++;
                
                swordID.image_xscale = 3;
                if (attack_combo % 2 == 1) {
                    swordID.image_yscale = 3;
                    alarm[0] = FIRST_ATTACK_CAN_ATTACK_DELAY; // time to reset can_attack for combo attacks
                    alarm[2] = FIRST_ATTACK_CAN_MOVE_DELAY; // time to reset can_move
                    alarm[3] = FIRST_ATTACK_COMBO_DELAY; // time for combo to expire
                    
                } // if
                else {
                    swordID.image_yscale = -3;
                     alarm[0] = SECOND_ATTACK_CAN_ATTACK_DELAY; // time to reset can_attack for combo attacks
                    alarm[2] = SECOND_ATTACK_CAN_MOVE_DELAY; // time to reset can_move
                    alarm[3] = SECOND_ATTACK_COMBO_DELAY; // time for combo to expire
                }
    
                swordID.image_angle = image_angle;
    
            }
            else {
                if (!attack_penalty) {
                    attack_penalty = true;
                    alarm[0] += ATTACK_PENALTY_CAN_ATTACK_DELAY; // extend time to reset can_attack.
                    alarm[2] += ATTACK_PENALTY_CAN_MOVE_DELAY; // still can't move
                    // alarm[3] will not be reset.  Bad timing misses chance to combo
                }
            }
        }
    }  
    
    
    // player moving
    if (can_move) {
    
        if (can_quickstep &amp;&amp; dash_button_pressed &amp;&amp; character_focus &gt; 0) {
            // do we have quickstep input?
            if (abs(x_axisL) &gt; .25 || abs(y_axisL) &gt; .25) {
                if (character_focus &gt;= QUICKSTEP_FOCUS_COST + 1) {
                    var stick_dir = point_direction(0, 0, x_axisL, y_axisL);
                    // what is the difference from character direction to input direction
                    var calc_dir = (image_angle - (stick_dir % 360)) * -1;
                    // for 4 directions, we have ranges of 90 degrees
                    // since angle 0 should be in the center of a range, we add 1/2 the range
                    //calc_dir += 45;
                    if (calc_dir &lt; 0) calc_dir += 360;
                    calc_dir = calc_dir % 360;
                    // calc_dir will be 0 if within 30 degrees either way
                    if (calc_dir &lt;= 30 || calc_dir &gt;= 330) calc_dir = 0;
                    // calc_dir will be 180 if within 30 degrees either way
                    if (calc_dir &gt;= 150 &amp;&amp; calc_dir &lt;= 210) calc_dir = 180;
                    
                    // now we know the direction, but we need the magnitude for that direction
                    var x_mag = 0;
                    var y_mag = 0;
                    
                    if (calc_dir &lt; 90 || calc_dir &gt; 270) x_mag = abs(dcos(calc_dir)) * QUICKSTEP_FORWARD_MULTIPLIER;
                    else x_mag = abs(dcos(calc_dir)) * QUICKSTEP_BACK_MULTIPLIER;
                    y_mag = abs(dsin(calc_dir)) * QUICKSTEP_SIDE_MULTIPLIER;
                    // now we have component magnitudes what is the result?
                    var calc_mag = point_distance(0,0,x_mag, y_mag);
                    // now we have a direction and a magnitude for movement in relation to image_direction
                    motion_set((image_angle + calc_dir), QUICKSTEP_SPEED_BASE * calc_mag);
                    // set starting friction and then each step it will increase
                    friction = QUICKSTEP_FRICTION_BASE;
                    quick_stepping = true;
                    can_quickstep = false;
                    can_move = false;
                    can_attack = false;
                    can_block = false;
                    alarm[7] = QUICKSTEP_COOLDOWN;
                    character_focus -= QUICKSTEP_FOCUS_COST;
                    audio_play_sound(snd_dash, 1, false);
                    
                }
            }
        } // end if (can_quickstep)
        
        // not quickstepping
        if (block_lock || block_held) {
            var new_x = x + x_axisL * MOVEMENT_SPEED * BLOCK_MOVEMENT_MULTIPLIER;
            var new_y = y + y_axisL * MOVEMENT_SPEED * BLOCK_MOVEMENT_MULTIPLIER;
        }
        else {
            var new_x = x + x_axisL * MOVEMENT_SPEED;
            var new_y = y + y_axisL * MOVEMENT_SPEED;
        }
        
        if (place_empty(new_x, new_y)) {
            x = new_x;
            y = new_y;
        } else if (place_empty(new_x, y)) x = new_x;
        else if (place_empty(x, new_y)) y = new_y;   
        
    }
    
    // player and sword moving
    if (swordID) {
        // advance to target while attacking as long as not quickstepping
        if(!quick_step_attack) {
            var x_adj;
            var y_adj;
            if (swordID.hit_blocked) {
                // both this object and the target would move back at half speed
                x_adj = dcos(image_angle - 180) * MOVEMENT_SPEED * ATTACK_MOVEMENT_MULTIPLIER;
                y_adj = dsin(image_angle - 180) * MOVEMENT_SPEED * ATTACK_MOVEMENT_MULTIPLIER;
                
                // collision detection for target
                
                // movement if no collision
                targetID.x -= x_adj;
                targetID.y += y_adj;
                
                // collision detection for me backing up
                
                // movement if no collision
                x += x_adj;
                y -= y_adj;
            }
            else {
                // free swing or hitting target
                var mult = swordID.speed_multiplier;
                x_adj = dcos(image_angle) * mult * MOVEMENT_SPEED;
                y_adj = dsin(image_angle) * mult * MOVEMENT_SPEED;
                // if collision with opponent
                if (place_meeting(x + x_adj, y - y_adj, targetID)) {
                    // if opponent can move back, push at half speed
                    x_adj *= ATTACK_PUSH_MULTIPLIER;
                    y_adj *= ATTACK_PUSH_MULTIPLIER;
                    with (targetID) {
                        // but only if space behind him is open
                        if (place_free(x + x_adj, y - y_adj)) {
                            // push him back!
                            x += x_adj;
                            y -= y_adj;
                        }
                        else {
                            // no one will move
                            x_adj = 0;
                            y_adj = 0;
                        }
                    }
                }
                x += x_adj;
                y -= y_adj;
            }
        }
        // always adjust sword position to player position
        swordID.x = x;
        swordID.y = y;
        swordID.image_angle = image_angle;
    }
    
    // player blocking
    if (shoulder_l_pressed) {
        if (can_block) {
            can_attack = false;
            can_block = false;
            can_quickstep = false;
            block_held = true;
            block_lock = true;
            alarm[4] = BLOCK_RAISE_DELAY;
            alarm[5] = BLOCK_LOCK_DELAY;
        }
        else if (block_lock) {
            block_held = true;
        }
    }
    
    if (shoulder_l_released) {
        block_held = false;
        if (!block_lock) {
            can_attack = true;
            blocking = false;
            can_block = true;
            // only enable quickstep if the timer is not set
            if (alarm[7] == -1) can_quickstep = true;
            invincible = false;
            image_index = NORMAL_IMAGE;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_charactersword">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle sword collision
// make sure it's not my sword
if (other.id != swordID) {
    if (!invincible) {
        if (alarm[4] &gt;= BLOCK_RAISE_DELAY - PARRY_THRESHOLD) {
            // successful parry
            audio_play_sound(snd_parry, 100, false) 
            attackerID = other.parentID
            // pushback attacker
            with (attackerID) {
                quick_stepping = true;
                // stunned
                stunned = true;
                alarm[8] = PARRIED_STUN_DELAY;
                
                blocking = false;
                block_lock = false;
                block_held = false;
                invincible = false;
                direction = image_angle - 180;
                speed = PARRIED_SPEED;
                friction = QUICKSTEP_FRICTION_BASE;
                // decrease opponent's stamina
                character_focus -= 20;
                // disassociate attacker's sword
                swordID = 0;
            }
            // destroy opponent sword
            with (other) instance_destroy();
    
            // increase my stamina
            character_focus += 20;
            
            // reset block-related states
            block_held = false;
            block_lock = false;
            can_attack = true;
            blocking = false;
            can_block = true;
            if (alarm[7] == -1) can_quickstep = true;
            invincible = false;
            image_index = NORMAL_IMAGE;
            // clear block-related alarms
            alarm[4] = -1;
            alarm[5] = -1;
        }
        else {
            // lose my sword
            if (swordID) {
                with (swordID) instance_destroy();
                swordID = 0;
            }
            
            // knockback
            x += dcos(targetID.direction) * KNOCKBACK;
            y -= dsin(targetID.direction) * KNOCKBACK;
            character_health--;
            image_index = DAMAGE_IMAGE;
            invincible = true;
            if (character_health == 0) {
                // dead.  freeze and set a timer for cleanup event
                can_move = false;
                can_attack = false;
                alarm[4] = -1;//don't be shielding
                alarm[5] = -1;
                var i;
                for (i = 0; i &lt; 12; i++){
                    alarm[i] = -1;
                }
                alarm[6] = RESPAWN_DELAY;
                // for fun, slow down room speed
                rm_arena.room_speed = CHARACTER_KILLED_ROOM_SPEED;
            }
            else alarm[1] = DAMAGE_DELAY;
            // sound when hit
            audio_play_sound(snd_hit, 1, false);
        }
    }
    else {
        // hit blocked?
        if (blocking &amp;&amp; other.hit_blocked != true) {
            other.hit_blocked = true;
            character_focus -= BLOCK_FOCUS_COST;
            audio_play_sound(snd_block, 1, false);
        }
        // ensure block lock
        if (alarm[5] &lt; BLOCK_LOCK_EXTENSION) {
            block_lock = true;
            alarm[5] = BLOCK_LOCK_EXTENSION;
        } 
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_character">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle Quickstep Collisions

if (quick_stepping &amp;&amp; !quickstep_collided) {
    var lock_swords = false;

    // get out of collision
    x = xprevious;
    y = yprevious;
    other.x = other.xprevious;
    other.y = other.yprevious;

    // at least one of us is quickstepping, now we are both effectively quickstepping.
    if (!other.quick_stepping) {
        stunned = true;
        alarm[8] = QUICKSTEP_SHORT_STUN_DELAY;
        character_focus += QUICKSTEP_SINGLE_COLLISION_FOCUS_BONUS;
        if (speed &gt;= QUICKSTEP_SPEED_THRESHOLD) other.alarm[8] = QUICKSTEP_LONG_STUN_DELAY;
        else other.alarm[8] = QUICKSTEP_SHORT_STUN_DELAY;
        with (other) {
            stunned = true;
            blocking = false;
            block_lock = false;
            block_held = false;
            invincible = false;
            image_index = NORMAL_IMAGE;
            character_focus -= QUICKSTEP_SINGLE_COLLISION_FOCUS_PENALTY;
        }
    }
    else {
        character_focus += QUICKSTEP_MUTUAL_COLLISION_FOCUS_BONUS;
        other.character_focus += QUICKSTEP_MUTUAL_COLLISION_FOCUS_BONUS;
        // both are quickstepping do we recoil or lock swords?
        if (speed &gt;= QUICKSTEP_SPEED_THRESHOLD &amp;&amp; other.speed &gt;= QUICKSTEP_SPEED_THRESHOLD) lock_swords = true;
        else {
            stunned = true;
            alarm[8] = QUICKSTEP_SHORT_STUN_DELAY;
            other.stunned = true;
            other.alarm[8] = QUICKSTEP_SHORT_STUN_DELAY;
        }
    }
    
    if (lock_swords) {
        
        sword_lock = true;
        sword_lock_button_count = 0;
        controlID.alarm[0]  = SWORD_LOCK_TIME_LIMIT;
        other.sword_lock = true;
        other.sword_lock_button_count = 0;
        

        // move characters into locked swords position
        // find distance between the characters
        var dist = point_distance(x, y, other.x, other.y);
        // what portion of the distance belongs to this player
        var tot_speed = speed + other.speed;
        dist = dist * speed / tot_speed;
        dist -= (sprite_height / 2);
        x += dist * dcos(direction);
        y -= dist * dsin(direction);
        speed = 0;
        
        // move the other along this direction as well, but offset from this object
        dist = other.sprite_height;
        other.x = x + dist * dcos(direction);
        other.y = y - dist * dsin(direction);
        other.speed = 0;
        
        // for now I'll just stun both characters will remove after sword-lock dynamic is done
        stunned = true;
        other.stunned = true;

    }
    else {
        // take the higher of the two speeds and use it as the new speed for both characters to bounce
        var high_speed = speed;
        var high_speed_direction = direction;
        var high_speed_friction = friction;
        if (other.speed &gt; high_speed) {
            high_speed = other.speed;
            direction = other.direction;
            other.direction -= 180;
            high_speed_friction = other.friction;
        }
        else {
            other.direction = direction;
            direction -= 180;
        }
        
        high_speed = high_speed * QUICKSTEP_COLLISION_MULTIPLIER;
        speed = high_speed;
        other.speed = high_speed;
        friction = high_speed_friction;
        other.friction = high_speed_friction;
    }
    

    other.quickstep_collided = true;
    quickstep_collided = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>24,24</point>
  </PhysicsShapePoints>
</object>
