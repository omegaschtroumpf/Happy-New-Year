<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_character</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input, Movement, Attacking, Blocking


// Regenerate Focus
if (focus_regen) {
    if (character_focus &lt; 0) {
        character_focus = 0;
        focus_regen = false;
        alarm[9] = FOCUS_REGEN_PENALTY;
        //break block if stamina is depleted
        block_lock = false;
        block_held = false;
    }
    else if (character_focus &lt; character_focus_max) {
        if (character_focus &lt; FOCUS_RATE_THRESHOLD) character_focus += FOCUS_REGEN_FAST;
        else character_focus += FOCUS_REGEN;
    }
}

// if quickstepping increase friction
if (speed &gt; 0) {
    friction *= QUICKSTEP_FRICTION_MULTIPLIER;
    if (speed &lt; QUICKSTEP_ATTACK_THRESHOLD &amp;&amp; !quick_step_attack) {
        can_attack = true;
    }
}
else {
    if (quick_stepping &amp;&amp; !swordID) {
        quick_stepping = false;
        quickstep_collided = false;
        can_move = true;
        can_block = true;
    }
}


if (!stunned || sword_lock) {

    // player input
    // left stick input
    x_axisL = gamepad_axis_value(deviceID, gp_axislh); // -1 .. 1
    y_axisL = gamepad_axis_value(deviceID, gp_axislv);
    x_axisR = gamepad_axis_value(deviceID, gp_axisrh);
    y_axisR = gamepad_axis_value(deviceID, gp_axisrv);
    
    if (keyboard_check(vk_right)) {
        x_axisL = 1;
    }
    if (keyboard_check(vk_left)) {
        x_axisL = -1;
    }
    if (keyboard_check(vk_up)) {
        y_axisL = -1;
    }
    if (keyboard_check(vk_down)) {
        y_axisL = 1;
    }    
    
    // slash button - Right button
    shoulder_r_pressed = gamepad_button_check_pressed(deviceID, gp_shoulderr);
    
    if (keyboard_check(vk_space)) || (keyboard_check(ord('X'))) {
        shoulder_r_pressed = 1;
    }
    else shoulder_r_pressed = 0;
    
    // blcok button - Left button
    shoulder_l_pressed = gamepad_button_check_pressed(deviceID, gp_shoulderl);
    shoulder_l_released = gamepad_button_check_released(deviceID, gp_shoulderl);
    
    if (keyboard_check_pressed(ord('C')) || keyboard_check_pressed(vk_alt)) {
        shoulder_l_pressed = 1;
    }
    else shoulder_l_pressed = 0;
    if (keyboard_check_released(ord('C')) || keyboard_check_pressed(vk_alt)) {
        shoulder_l_released = 1;
    }
    else shoulder_l_released = 0;
    
    // dash button - XBOX A Button
    dash_button_pressed = gamepad_button_check_pressed(deviceID, gp_face1);
    
    if (keyboard_check(ord('V'))) {
        dash_button_pressed = 1;
    }
    else dash_button_pressed = 0;
    
    // target cancel button
    target_cancel_button_pressed = gamepad_button_check_pressed(deviceID, gp_stickr) || gamepad_button_check_pressed(deviceID, gp_stickl);
    
    if (keyboard_check(ord('G'))) {
        target_cancel_button_pressed = 1;
    }
    else target_cancel_button_pressed = 0;
    
    // target keyboard button
    if (keyboard_check(ord('T'))) {
        target_button_pressed = 1;
    }
    else target_button_pressed = 0;
}

if (!stunned) {
    if (can_target) {
        // if right stick input without cancelling target, point that way as a starting point for soft targeting
        if ((x_axisR != 0 || y_axisR != 0) &amp;&amp; !target_cancel_button_pressed) {
            soft_target = true;
            targetID = 0;
            image_angle = point_direction(0, 0, x_axisR, y_axisR);
        }
        if (target_button_pressed) {
            soft_target = true;
            targetID = 0;
        }
        if (target_cancel_button_pressed) {
            soft_target = false;
            targetID = 0;
        }
        if (soft_target) {
            // clear out angles list in case there's anything there.  we'll populate it here and potentially refer to it when attacking
            ds_list_clear(softTargetAngles);
            // look for enemies and calculate a new image_angle
            // go through the enemies' positions and see if they are in my line of sight
            num = ds_list_size(enemiesID);
            vector_x = 0;
            vector_y = 0;
            see_enemies = false;
            for (i = 0; i &lt; num; i++) {
                enemy = ds_list_find_value(enemiesID, i);
                enemy_distance = point_distance(x, y, enemy.x, enemy.y);
                // only do more calculation with this enemy if he is in range
                if (enemy_distance &lt;= TARGET_MAX_DISTANCE) {
                    enemy_direction = point_direction(x, y, enemy.x, enemy.y);
                    ds_list_add(softTargetAngles, enemy_direction);
                    angle_diff = angle_difference(image_angle, enemy_direction);
                    if ((angle_diff &lt; TARGET_ANGLE / 2) &amp;&amp; angle_diff &gt; (TARGET_ANGLE / -2)) {
                        // in my line of sight, add to my vector calculations
                        see_enemies = true;
                        // distance to enemy will weight the vectoring, the farther away, the lower the influence an enemy has on targeting
                        // enemy.x - x because I want to point from me at relative 0,0 towards enemy
                        vector_x += (enemy.x - x) / sqr(sqr(enemy_distance));
                        vector_y += (enemy.y - y) / sqr(sqr(enemy_distance));
                    }
                }
            }
            // if I saw enemies, adjust my angle to face them.  If not, I'll keep my angle from right stick
            if (see_enemies) {
                // now I have a vector for the weighted direction towards enemies.
                image_angle = point_direction(0, 0, vector_x, vector_y);
            }
            else {
                soft_target = false;
            }
        }
        // If I have a specific enemy target, just look at him
        else if (targetID) {            
            image_angle = point_direction(x, y, targetID.x,targetID.y);
        }
        // I aint got no target
        else {
            // what the hell direction am I moving in then?
            if (x_axisL != 0 || y_axisL != 0) image_angle = point_direction(0, 0, x_axisL, y_axisL);
        }
    }
    
    // player attacking
    if (shoulder_r_pressed) {
        if (swordID = 0 &amp;&amp; !block_held &amp;&amp; !block_lock) {
            if (can_attack &amp;&amp; character_focus &gt; 0) {
                if (quick_stepping) quick_step_attack = true;
                can_attack = false;
                can_block = false;
                can_move = false;
                can_target = false;
                var attack_speed = character_focus / 100;
                if (attack_speed &lt; .5) attack_speed = .5;
                character_focus -= (FIRST_ATTACK_FOCUS_COST + (attack_combo * SUCCESSIVE_ATTACK_FOCUS_MODIFIER))
                swordID = instance_create(x, y, obj_charactersword); // create a sword and keep its ID to ignore collisions
                swordID.attack_speed = attack_speed;
                swordID.image_speed *= attack_speed;
                // set sword parentID so it can destroy itself and clear its parent's swordID;
                swordID.parentID = id;
                attack_combo++;
                
                swordID.image_xscale = 3;
                if (attack_combo % 2 == 1) {
                    swordID.image_yscale = 3;
                    alarm[0] = FIRST_ATTACK_CAN_ATTACK_DELAY; // time to reset can_attack for combo attacks
                    alarm[2] = FIRST_ATTACK_CAN_MOVE_DELAY; // time to reset can_move
                    alarm[3] = FIRST_ATTACK_COMBO_DELAY; // time for combo to expire
                    
                } // if
                else {
                    swordID.image_yscale = -3;
                    alarm[0] = SECOND_ATTACK_CAN_ATTACK_DELAY; // time to reset can_attack for combo attacks
                    alarm[2] = SECOND_ATTACK_CAN_MOVE_DELAY; // time to reset can_move
                    alarm[3] = SECOND_ATTACK_COMBO_DELAY; // time for combo to expire
                }
                // if we are soft targeting and have directional input, direct the attack
                // toward the soft-targeted enemy whose angle is closest to input angle
                if (soft_target &amp;&amp; (x_axisL != 0 || y_axisL != 0)){
                    stick_angle = point_direction(0, 0, x_axisL, y_axisL);
                    num = ds_list_size(softTargetAngles);
                    smallest_angle_diff = 181; // angle_difference() returns a value -180..180
                    new_angle = 0; // This will change.  if we are soft_targeting, we can assume at least one enemy in view
                    for (i = 0; i &lt; num; i++) {
                        target_angle = ds_list_find_value(softTargetAngles, i);
                        angle_diff = abs(angle_difference(stick_angle, target_angle));
                        if (angle_diff &lt; smallest_angle_diff) {
                            smallest_angle_diff = angle_diff;
                            new_angle = target_angle;
                        }
                    }
                    image_angle = new_angle;
                }    
                swordID.image_angle = image_angle;
    
            }
            else {
                if (!attack_penalty) {
                    attack_penalty = true;
                    alarm[0] += ATTACK_PENALTY_CAN_ATTACK_DELAY; // extend time to reset can_attack.
                    alarm[2] += ATTACK_PENALTY_CAN_MOVE_DELAY; // still can't move
                    // alarm[3] will not be reset.  Bad timing misses chance to combo
                }
            }
        }
    }  
    
    
    // player moving
    if (can_move) {
    
        if (can_quickstep &amp;&amp; dash_button_pressed &amp;&amp; character_focus &gt; 0) {
            // do we have quickstep input?
            if (abs(x_axisL) &gt; .35 || abs(y_axisL) &gt; .35) {
                if (character_focus &gt;= QUICKSTEP_FOCUS_COST + 1) {
                    var stick_dir = point_direction(0, 0, x_axisL, y_axisL);
                    // what is the difference from character direction to input direction
                    var calc_dir = (image_angle - (stick_dir % 360)) * -1;
                    // for 4 directions, we have ranges of 90 degrees
                    // since angle 0 should be in the center of a range, we add 1/2 the range
                    //calc_dir += 45;
                    if (calc_dir &lt; 0) calc_dir += 360;
                    calc_dir = calc_dir % 360;
                    // calc_dir will be 0 if within 30 degrees either way
                    if (calc_dir &lt;= 30 || calc_dir &gt;= 330) calc_dir = 0;
                    // calc_dir will be 180 if within 30 degrees either way
                    if (calc_dir &gt;= 150 &amp;&amp; calc_dir &lt;= 210) calc_dir = 180;
                    
                    // now we know the direction, but we need the magnitude for that direction
                    var x_mag = 0;
                    var y_mag = 0;
                    
                    if (calc_dir &lt; 90 || calc_dir &gt; 270) x_mag = abs(dcos(calc_dir)) * QUICKSTEP_FORWARD_MULTIPLIER;
                    else x_mag = abs(dcos(calc_dir)) * QUICKSTEP_BACK_MULTIPLIER;
                    y_mag = abs(dsin(calc_dir)) * QUICKSTEP_SIDE_MULTIPLIER;
                    // now we have component magnitudes what is the result?
                    var calc_mag = point_distance(0,0,x_mag, y_mag);
                    // now we have a direction and a magnitude for movement in relation to image_direction
                    motion_set((image_angle + calc_dir), QUICKSTEP_SPEED_BASE * calc_mag);
                    // set starting friction and then each step it will increase
                    friction = QUICKSTEP_FRICTION_BASE;
                    quick_stepping = true;
                    can_quickstep = false;
                    can_move = false;
                    can_attack = false;
                    can_block = false;
                    alarm[7] = QUICKSTEP_COOLDOWN;
                    character_focus -= QUICKSTEP_FOCUS_COST;
                    audio_play_sound(snd_dash, 1, false);
                }
            }
        } // end if (can_quickstep)
        
        // not quickstepping
        if (block_lock || block_held) {
            var new_x = x + x_axisL * MOVEMENT_SPEED * BLOCK_MOVEMENT_MULTIPLIER;
            var new_y = y + y_axisL * MOVEMENT_SPEED * BLOCK_MOVEMENT_MULTIPLIER;
        }
        else {
            var new_x = x + x_axisL * MOVEMENT_SPEED;
            var new_y = y + y_axisL * MOVEMENT_SPEED;
        }
        
        if (place_empty(new_x, new_y)) {
            x = new_x;
            y = new_y;
        } else if (place_empty(new_x, y)) x = new_x;
        else if (place_empty(x, new_y)) y = new_y;   
        
    }
    
    // player and sword moving
    if (swordID) {
        // advance to target while attacking as long as not quickstepping
        if(!quick_step_attack) {
            var x_adj;
            var y_adj;
            if (swordID.hit_blocked) {
                // both this object and the target would move back at half speed
                x_adj = dcos(image_angle - 180) * MOVEMENT_SPEED * ATTACK_MOVEMENT_MULTIPLIER;
                y_adj = dsin(image_angle - 180) * MOVEMENT_SPEED * ATTACK_MOVEMENT_MULTIPLIER;
                
                // collision detection for target
                
                // movement if no collision
                targetID.x -= x_adj;
                targetID.y += y_adj;
                
                // collision detection for me backing up
                
                // movement if no collision
                x += x_adj;
                y -= y_adj;
            }
            else {
                // free swing or hitting target
                var mult = swordID.speed_multiplier;
                x_adj = dcos(image_angle) * mult * MOVEMENT_SPEED;
                y_adj = dsin(image_angle) * mult * MOVEMENT_SPEED;
                // if collision with opponent
                if (place_meeting(x + x_adj, y - y_adj, targetID)) {
                    // if opponent can move back, push at half speed
                    x_adj *= ATTACK_PUSH_MULTIPLIER;
                    y_adj *= ATTACK_PUSH_MULTIPLIER;
                    with (targetID) {
                        // but only if space behind him is open
                        if (place_free(x + x_adj, y - y_adj)) {
                            // push him back!
                            x += x_adj;
                            y -= y_adj;
                        }
                        else {
                            // no one will move
                            x_adj = 0;
                            y_adj = 0;
                        }
                    }
                }
                x += x_adj;
                y -= y_adj;
            }
        }
        // always adjust sword position to player position
        swordID.x = x;
        swordID.y = y;
        swordID.image_angle = image_angle;
    }
    
    // player blocking
    if (shoulder_l_pressed) {
        if (can_block) {
            can_attack = false;
            can_block = false;
            can_quickstep = false;
            block_held = true;
            block_lock = true;
            alarm[4] = BLOCK_RAISE_DELAY;
            alarm[5] = BLOCK_LOCK_DELAY;
        }
        else if (block_lock) {
            block_held = true;
        }
    }
    
    if (shoulder_l_released) {
        block_held = false;
        if (!block_lock) {
            can_attack = true;
            blocking = false;
            can_block = true;
            // only enable quickstep if the timer is not set
            if (alarm[7] == -1) can_quickstep = true;
            invincible = false;
            image_index = NORMAL_IMAGE;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>24,24</point>
  </PhysicsShapePoints>
</object>
