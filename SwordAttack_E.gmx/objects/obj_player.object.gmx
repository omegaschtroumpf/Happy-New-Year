<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_character</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input, Movement, Attacking, Blocking


// Regenerate Focus
if (focus_regen) {
    if (character_focus &lt; 0) {
        character_focus = 0;
        focus_regen = false;
        alarm[9] = FOCUS_REGEN_PENALTY;
        //break block if stamina is depleted
        block_lock = false;
        block_held = false;
    }
    else if (character_focus &lt; character_focus_max) {
        if (character_focus &lt; FOCUS_RATE_THRESHOLD) character_focus += FOCUS_REGEN_FAST;
        else character_focus += FOCUS_REGEN;
    }
}

// if quickstepping increase friction
if (speed &gt; 0) {
    friction *= QUICKSTEP_FRICTION_MULTIPLIER;
    if (speed &lt; QUICKSTEP_ATTACK_THRESHOLD &amp;&amp; !quick_step_attack) {
        can_attack = true;
    }
}
else {
    if (quick_stepping &amp;&amp; !swordID) {
        quick_stepping = false;
        quickstep_collided = false;
        can_move = true;
        can_block = true;
    }
}


if (!stunned || sword_lock) {

    // player input
    // left stick input
    x_axisL = gamepad_axis_value(deviceID, gp_axislh); // -1 .. 1
    y_axisL = gamepad_axis_value(deviceID, gp_axislv);
    x_axisR = gamepad_axis_value(deviceID, gp_axisrh);
    y_axisR = gamepad_axis_value(deviceID, gp_axisrv);
    
    if (keyboard_check(vk_right)) {
        x_axisL = 1;
    }
    if (keyboard_check(vk_left)) {
        x_axisL = -1;
    }
    if (keyboard_check(vk_up)) {
        y_axisL = -1;
    }
    if (keyboard_check(vk_down)) {
        y_axisL = 1;
    }    
    
    // slash button - Right button
    shoulder_r_pressed = gamepad_button_check_pressed(deviceID, gp_shoulderr);
    
    if (keyboard_check(vk_space)) || (keyboard_check(ord('X'))) {
        shoulder_r_pressed = 1;
    }  
    
    // blcok button - Left button
    shoulder_l_pressed = gamepad_button_check_pressed(deviceID, gp_shoulderl);
    shoulder_l_released = gamepad_button_check_released(deviceID, gp_shoulderl);
    
    if (keyboard_check_pressed(ord('C')) || keyboard_check_pressed(vk_alt)) {
        shoulder_l_pressed = 1;
    }
    if (keyboard_check_released(ord('C')) || keyboard_check_pressed(vk_alt)) {
        shoulder_l_released = 1;
    }
    
    
    // dash button - XBOX A Button
    dash_button_pressed = gamepad_button_check_pressed(deviceID, gp_face1);
    
    if (keyboard_check(ord('V'))) {
        dash_button_pressed = 1;
    }  
}

if (!stunned) {

    if (can_target) {
        image_angle = point_direction(x,y,targetID.x,targetID.y);
    }
    
    // player attacking
    if (shoulder_r_pressed) {
        if (swordID = 0 &amp;&amp; !block_held &amp;&amp; !block_lock) {
            if (can_attack &amp;&amp; character_focus &gt; 0) {
                if (quick_stepping) quick_step_attack = true;
                can_attack = false;
                can_block = false;
                can_move = false;
                var attack_speed = character_focus / 100;
                if (attack_speed &lt; .5) attack_speed = .5;
                character_focus -= (FIRST_ATTACK_FOCUS_COST + (attack_combo * SUCCESSIVE_ATTACK_FOCUS_MODIFIER))
                swordID = instance_create(x, y, obj_charactersword); // create a sword and keep its ID to ignore collisions
                swordID.attack_speed = attack_speed;
                swordID.image_speed *= attack_speed;
                /*
                Reference an object with it's object ID
                This next line translates to:
                Store this object's (character's) object ID in the parentID field
                of the object identified by swordID.
                That way, when the sword is done doing its thing, it can destroy itself and clear
                its parentID.swordID to 0;
                */
                swordID.parentID = id;
                attack_combo++;
                
                swordID.image_xscale = 3;
                if (attack_combo % 2 == 1) {
                    swordID.image_yscale = 3;
                    alarm[0] = FIRST_ATTACK_CAN_ATTACK_DELAY; // time to reset can_attack for combo attacks
                    alarm[2] = FIRST_ATTACK_CAN_MOVE_DELAY; // time to reset can_move
                    alarm[3] = FIRST_ATTACK_COMBO_DELAY; // time for combo to expire
                    
                } // if
                else {
                    swordID.image_yscale = -3;
                     alarm[0] = SECOND_ATTACK_CAN_ATTACK_DELAY; // time to reset can_attack for combo attacks
                    alarm[2] = SECOND_ATTACK_CAN_MOVE_DELAY; // time to reset can_move
                    alarm[3] = SECOND_ATTACK_COMBO_DELAY; // time for combo to expire
                }
    
                swordID.image_angle = image_angle;
    
            }
            else {
                if (!attack_penalty) {
                    attack_penalty = true;
                    alarm[0] += ATTACK_PENALTY_CAN_ATTACK_DELAY; // extend time to reset can_attack.
                    alarm[2] += ATTACK_PENALTY_CAN_MOVE_DELAY; // still can't move
                    // alarm[3] will not be reset.  Bad timing misses chance to combo
                }
            }
        }
    }  
    
    
    // player moving
    if (can_move) {
    
        if (can_quickstep &amp;&amp; dash_button_pressed &amp;&amp; character_focus &gt; 0) {
            // do we have quickstep input?
            if (abs(x_axisL) &gt; .35 || abs(y_axisL) &gt; .35) {
                if (character_focus &gt;= QUICKSTEP_FOCUS_COST + 1) {
                    var stick_dir = point_direction(0, 0, x_axisL, y_axisL);
                    // what is the difference from character direction to input direction
                    var calc_dir = (image_angle - (stick_dir % 360)) * -1;
                    // for 4 directions, we have ranges of 90 degrees
                    // since angle 0 should be in the center of a range, we add 1/2 the range
                    //calc_dir += 45;
                    if (calc_dir &lt; 0) calc_dir += 360;
                    calc_dir = calc_dir % 360;
                    // calc_dir will be 0 if within 30 degrees either way
                    if (calc_dir &lt;= 30 || calc_dir &gt;= 330) calc_dir = 0;
                    // calc_dir will be 180 if within 30 degrees either way
                    if (calc_dir &gt;= 150 &amp;&amp; calc_dir &lt;= 210) calc_dir = 180;
                    
                    // now we know the direction, but we need the magnitude for that direction
                    var x_mag = 0;
                    var y_mag = 0;
                    
                    if (calc_dir &lt; 90 || calc_dir &gt; 270) x_mag = abs(dcos(calc_dir)) * QUICKSTEP_FORWARD_MULTIPLIER;
                    else x_mag = abs(dcos(calc_dir)) * QUICKSTEP_BACK_MULTIPLIER;
                    y_mag = abs(dsin(calc_dir)) * QUICKSTEP_SIDE_MULTIPLIER;
                    // now we have component magnitudes what is the result?
                    var calc_mag = point_distance(0,0,x_mag, y_mag);
                    // now we have a direction and a magnitude for movement in relation to image_direction
                    motion_set((image_angle + calc_dir), QUICKSTEP_SPEED_BASE * calc_mag);
                    // set starting friction and then each step it will increase
                    friction = QUICKSTEP_FRICTION_BASE;
                    quick_stepping = true;
                    can_quickstep = false;
                    can_move = false;
                    can_attack = false;
                    can_block = false;
                    alarm[7] = QUICKSTEP_COOLDOWN;
                    character_focus -= QUICKSTEP_FOCUS_COST;
                    audio_play_sound(snd_dash, 1, false);
                }
            }
        } // end if (can_quickstep)
        
        // not quickstepping
        if (block_lock || block_held) {
            var new_x = x + x_axisL * MOVEMENT_SPEED * BLOCK_MOVEMENT_MULTIPLIER;
            var new_y = y + y_axisL * MOVEMENT_SPEED * BLOCK_MOVEMENT_MULTIPLIER;
        }
        else {
            var new_x = x + x_axisL * MOVEMENT_SPEED;
            var new_y = y + y_axisL * MOVEMENT_SPEED;
        }
        
        if (place_empty(new_x, new_y)) {
            x = new_x;
            y = new_y;
        } else if (place_empty(new_x, y)) x = new_x;
        else if (place_empty(x, new_y)) y = new_y;   
        
    }
    
    // player and sword moving
    if (swordID) {
        // advance to target while attacking as long as not quickstepping
        if(!quick_step_attack) {
            var x_adj;
            var y_adj;
            if (swordID.hit_blocked) {
                // both this object and the target would move back at half speed
                x_adj = dcos(image_angle - 180) * MOVEMENT_SPEED * ATTACK_MOVEMENT_MULTIPLIER;
                y_adj = dsin(image_angle - 180) * MOVEMENT_SPEED * ATTACK_MOVEMENT_MULTIPLIER;
                
                // collision detection for target
                
                // movement if no collision
                targetID.x -= x_adj;
                targetID.y += y_adj;
                
                // collision detection for me backing up
                
                // movement if no collision
                x += x_adj;
                y -= y_adj;
            }
            else {
                // free swing or hitting target
                var mult = swordID.speed_multiplier;
                x_adj = dcos(image_angle) * mult * MOVEMENT_SPEED;
                y_adj = dsin(image_angle) * mult * MOVEMENT_SPEED;
                // if collision with opponent
                if (place_meeting(x + x_adj, y - y_adj, targetID)) {
                    // if opponent can move back, push at half speed
                    x_adj *= ATTACK_PUSH_MULTIPLIER;
                    y_adj *= ATTACK_PUSH_MULTIPLIER;
                    with (targetID) {
                        // but only if space behind him is open
                        if (place_free(x + x_adj, y - y_adj)) {
                            // push him back!
                            x += x_adj;
                            y -= y_adj;
                        }
                        else {
                            // no one will move
                            x_adj = 0;
                            y_adj = 0;
                        }
                    }
                }
                x += x_adj;
                y -= y_adj;
            }
        }
        // always adjust sword position to player position
        swordID.x = x;
        swordID.y = y;
        swordID.image_angle = image_angle;
    }
    
    // player blocking
    if (shoulder_l_pressed) {
        if (can_block) {
            can_attack = false;
            can_block = false;
            can_quickstep = false;
            block_held = true;
            block_lock = true;
            alarm[4] = BLOCK_RAISE_DELAY;
            alarm[5] = BLOCK_LOCK_DELAY;
        }
        else if (block_lock) {
            block_held = true;
        }
    }
    
    if (shoulder_l_released) {
        block_held = false;
        if (!block_lock) {
            can_attack = true;
            blocking = false;
            can_block = true;
            // only enable quickstep if the timer is not set
            if (alarm[7] == -1) can_quickstep = true;
            invincible = false;
            image_index = NORMAL_IMAGE;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>24,24</point>
  </PhysicsShapePoints>
</object>
