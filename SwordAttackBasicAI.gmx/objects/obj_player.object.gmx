<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>obj_character</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize Variables

// Character constants
MOVEMENT_SPEED = 3;
KNOCKBACK = 5;
FOCUS_RATE_THRESHOLD = 50;
FOCUS_MAX = 100;
FOCUS_REGEN = 7 / 30; // 14 / 30 // ~14 PER SECOND
FOCUS_REGEN_FAST = 1 / 3; // 1 / 3 20 PER SECOND
FOCUS_REGEN_PENALTY = 90; // when focus &lt; 0, # steps regen is suspended
QUICKSTEP_SPEED_BASE = 15;
QUICKSTEP_FORWARD_MULTIPLIER = 1.75;
QUICKSTEP_BACK_MULTIPLIER = 1.5;
QUICKSTEP_SIDE_MULTIPLIER = 4 / 3;
QUICKSTEP_FRICTION_BASE = 1.5
QUICKSTEP_FRICTION_MULTIPLIER = 1.2;
QUICKSTEP_ATTACK_THRESHOLD = 20;
QUICKSTEP_COOLDOWN = 30;
QUICKSTEP_COLLISION_MULTIPLIER = .75;
QUICKSTEP_MUTUAL_COLLISION_FOCUS_BONUS = 10;
QUICKSTEP_SINGLE_COLLISION_FOCUS_BONUS = 20;
QUICKSTEP_SINGLE_COLLISION_FOCUS_PENALTY = 40;
QUICKSTEP_SPEED_THRESHOLD = 20;
QUICKSTEP_SHORT_STUN_DELAY = 10;
QUICKSTEP_LONG_STUN_DELAY = 30;
QUICKSTEP_FOCUS_COST = 40;
SWORD_LOCK_TIME_LIMIT = 90;
SWORD_LOCK_BUTTON_LEAD = 10;
BLOCK_MOVEMENT_MULTIPLIER = .5;
ATTACK_MOVEMENT_MULTIPLIER = .5;
POWER_ATTACK_MOVEMENT_MULTIPLIER = 2;
ATTACK_PUSH_MULTIPLIER = .25;
FIRST_ATTACK_CAN_ATTACK_DELAY = 12;
FIRST_ATTACK_CAN_MOVE_DELAY = 15;
FIRST_ATTACK_COMBO_DELAY = 15;
FIRST_ATTACK_FOCUS_COST = 20;
SUCCESSIVE_ATTACK_FOCUS_MODIFIER = 12;
SECOND_ATTACK_CAN_ATTACK_DELAY = 30;
SECOND_ATTACK_CAN_MOVE_DELAY = 30;
SECOND_ATTACK_COMBO_DELAY = 30;
SECOND_ATTACK_FOCUS_COST = 30;
ATTACK_PENALTY_CAN_ATTACK_DELAY = 12;
ATTACK_PENALTY_CAN_MOVE_DELAY = 12;
BLOCK_RAISE_DELAY = 7;
BLOCK_LOCK_DELAY = 30;
BLOCK_LOCK_EXTENSION = 15;
BLOCK_FOCUS_COST = 30;
RESPAWN_DELAY = 7;
DAMAGE_DELAY = 7;
NORMAL_IMAGE = 0;
DAMAGE_IMAGE = 1;
BLOCKING_IMAGE = 2;
CHARACTER_KILLED_ROOM_SPEED = 10;
NORMAL_ROOM_SPEED = 30;

// Sprite property assignments - won't be needed once we have custom sprites
image_xscale = 3;
image_yscale = 3;
image_speed = 0;
image_angle = direction;


// character state variables
character_health = 2; //currently just tracking player hits
character_focus_max = FOCUS_MAX; // 100 to start.  Could get hit and drop to 70.
character_focus = FOCUS_MAX; // this is for later
focus_regen = true; // can regenerate focus
can_move = true; // applies to motion and auto-target direction changes
can_target = true;
can_attack = true;
can_block = true;
can_quickstep = true;
quick_stepping = false;
quick_step_attack = false;
sword_lock = false;
sword_lock_button_count = 0;
unfocused = false; // set to true at completion of action that decremented focus to/below 0
stunned = false;
attack_combo = 0; // track the number of sequential attacks for correct animation
attack_penalty = false; //
block_held = false; // set to true when block button is pressed, false when block button is released
blocking = false; // set to true when block is raised
block_lock = false; // ensures the minimum block time
invincible = false; // this stays set for the greater of minimum block time, or the time that the player holds the block button beyond minimum block time
quickstep_collided = false;

/*
continue_attack = false;
follow_up_attack = false;
*/

// related objects
targetID = 0;
swordID = 0;
controlID = 0;
statsID = 0;




// player controller input variables
deviceID = -1; // this is set by the room or when character dies and replacement is made
controller_side = ""; // this will be set to "left" or "right"
x_axis = 0;
y_axis = 0;

attack_button_pressed = 0;
dash_button_pressed = 0;
target_button_pressed = 0;
block_button_pressed = 0;
block_button_released = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input, Movement, Attacking, Blocking

// Regenerate Focus
if (focus_regen) {
    if (character_focus &lt; 0) {
        character_focus = 0;
        focus_regen = false;
        alarm[9] = FOCUS_REGEN_PENALTY;
    }
    else if (character_focus &lt; character_focus_max) {
        if (character_focus &lt; FOCUS_RATE_THRESHOLD) character_focus += FOCUS_REGEN_FAST;
        else character_focus += FOCUS_REGEN;
    }
}

// if quickstepping increase friction
if (speed &gt; 0) {
    friction *= QUICKSTEP_FRICTION_MULTIPLIER;
    if (speed &lt; QUICKSTEP_ATTACK_THRESHOLD &amp;&amp; !quick_step_attack) {
        can_attack = true;
    }
}
else {
    if (quick_stepping &amp;&amp; !swordID) {
        quick_stepping = false;
        quickstep_collided = false;
        can_move = true;
        can_block = true;
    }
}


if (!stunned || sword_lock) {

    // player input
    // left stick input
    if (controller_side == "left") {
        x_axis = gamepad_axis_value(deviceID, gp_axislh); // -1 .. 1
        y_axis = gamepad_axis_value(deviceID, gp_axislv);
        attack_button_pressed = gamepad_button_check_pressed(deviceID, gp_shoulderl);
        dash_button_pressed = gamepad_button_check_pressed(deviceID, gp_shoulderlb);
        target_button_pressed = gamepad_button_check_pressed(deviceID, gp_stickl);
    }
    else if (controller_side == "right"){
        x_axis = gamepad_axis_value(deviceID, gp_axisrh);
        y_axis = gamepad_axis_value(deviceID, gp_axisrv);
        attack_button_pressed = gamepad_button_check_pressed(deviceID, gp_shoulderr);
        dash_button_pressed = gamepad_button_check_pressed(deviceID, gp_shoulderrb);
        target_button_pressed = gamepad_button_check_pressed(deviceID, gp_stickr);        
    }
}

if (!stunned) {

    if (can_target) {
        image_angle = point_direction(x,y,targetID.x,targetID.y);
    }
    
    // player attacking
    if (attack_button_pressed) {
        if (swordID = 0 &amp;&amp; !block_held &amp;&amp; !block_lock) {
            if (can_attack &amp;&amp; character_focus &gt; 0) {
                if (quick_stepping) quick_step_attack = true;
                can_attack = false;
                can_block = false;
                can_move = false;
                var attack_speed = character_focus / 100;
                if (attack_speed &lt; .5) attack_speed = .5;
                character_focus -= (FIRST_ATTACK_FOCUS_COST + (attack_combo * SUCCESSIVE_ATTACK_FOCUS_MODIFIER))
                swordID = instance_create(x, y, obj_charactersword); // create a sword and keep its ID to ignore collisions
                swordID.attack_speed = attack_speed;
                swordID.image_speed *= attack_speed;
                /*
                Reference an object with it's object ID
                This next line translates to:
                Store this object's (character's) object ID in the parentID field
                of the object identified by swordID.
                That way, when the sword is done doing its thing, it can destroy itself and clear
                its parentID.swordID to 0;
                */
                swordID.parentID = id;
                attack_combo++;
                
                swordID.image_xscale = 3;
                if (attack_combo % 2 == 1) {
                    swordID.image_yscale = 3;
                    alarm[0] = FIRST_ATTACK_CAN_ATTACK_DELAY; // time to reset can_attack for combo attacks
                    alarm[2] = FIRST_ATTACK_CAN_MOVE_DELAY; // time to reset can_move
                    alarm[3] = FIRST_ATTACK_COMBO_DELAY; // time for combo to expire
                    
                } // if
                else {
                    swordID.image_yscale = -3;
                     alarm[0] = SECOND_ATTACK_CAN_ATTACK_DELAY; // time to reset can_attack for combo attacks
                    alarm[2] = SECOND_ATTACK_CAN_MOVE_DELAY; // time to reset can_move
                    alarm[3] = SECOND_ATTACK_COMBO_DELAY; // time for combo to expire
                }
    
                swordID.image_angle = image_angle;
    
            }
            else {
                if (!attack_penalty) {
                    attack_penalty = true;
                    alarm[0] += ATTACK_PENALTY_CAN_ATTACK_DELAY; // extend time to reset can_attack.
                    alarm[2] += ATTACK_PENALTY_CAN_MOVE_DELAY; // still can't move
                    // alarm[3] will not be reset.  Bad timing misses chance to combo
                }
            }
        }
    }  
    
    
    // player moving
    if (can_move) {
    
        if (can_quickstep &amp;&amp; dash_button_pressed &amp;&amp; character_focus &gt; 0) {
            // do we have quickstep input?
            if (abs(x_axis) &gt; .25 || abs(y_axis) &gt; .25) {
                if (character_focus &gt;= QUICKSTEP_FOCUS_COST + 1) {
                    var stick_dir = point_direction(0, 0, x_axis, y_axis);
                    // what is the difference from character direction to input direction
                    var calc_dir = (image_angle - (stick_dir % 360)) * -1;
                    // for 4 directions, we have ranges of 90 degrees
                    // since angle 0 should be in the center of a range, we add 1/2 the range
                    //calc_dir += 45;
                    if (calc_dir &lt; 0) calc_dir += 360;
                    calc_dir = calc_dir % 360;
                    // calc_dir will be 0 if within 30 degrees either way
                    if (calc_dir &lt;= 30 || calc_dir &gt;= 330) calc_dir = 0;
                    // calc_dir will be 180 if within 30 degrees either way
                    if (calc_dir &gt;= 150 &amp;&amp; calc_dir &lt;= 210) calc_dir = 180;
                    
                    // now we know the direction, but we need the magnitude for that direction
                    var x_mag = 0;
                    var y_mag = 0;
                    
                    if (calc_dir &lt; 90 || calc_dir &gt; 270) x_mag = abs(dcos(calc_dir)) * QUICKSTEP_FORWARD_MULTIPLIER;
                    else x_mag = abs(dcos(calc_dir)) * QUICKSTEP_BACK_MULTIPLIER;
                    y_mag = abs(dsin(calc_dir)) * QUICKSTEP_SIDE_MULTIPLIER;
                    // now we have component magnitudes what is the result?
                    var calc_mag = point_distance(0,0,x_mag, y_mag);
                    // now we have a direction and a magnitude for movement in relation to image_direction
                    motion_set((image_angle + calc_dir), QUICKSTEP_SPEED_BASE * calc_mag);
                    // set starting friction and then each step it will increase
                    friction = QUICKSTEP_FRICTION_BASE;
                    quick_stepping = true;
                    can_quickstep = false;
                    can_move = false;
                    can_attack = false;
                    can_block = false;
                    alarm[7] = QUICKSTEP_COOLDOWN;
                    character_focus -= QUICKSTEP_FOCUS_COST;
                }
            }
        } // end if (can_quickstep)
        
        // not quickstepping
        if (block_lock || block_held) {
            var new_x = x + x_axis * MOVEMENT_SPEED * BLOCK_MOVEMENT_MULTIPLIER;
            var new_y = y + y_axis * MOVEMENT_SPEED * BLOCK_MOVEMENT_MULTIPLIER;
        }
        else {
            var new_x = x + x_axis * MOVEMENT_SPEED;
            var new_y = y + y_axis * MOVEMENT_SPEED;
        }
        
        if (place_empty(new_x, new_y)) {
            x = new_x;
            y = new_y;
        } else if (place_empty(new_x, y)) x = new_x;
        else if (place_empty(x, new_y)) y = new_y;   
        
    }
    
    // player and sword moving
    if (swordID) {
        // advance to target while attacking as long as not quickstepping
        if(!quick_step_attack) {
            var x_adj;
            var y_adj;
            if (swordID.hit_blocked) {
                // both this object and the target would move back at half speed
                x_adj = dcos(image_angle - 180) * MOVEMENT_SPEED * ATTACK_MOVEMENT_MULTIPLIER;
                y_adj = dsin(image_angle - 180) * MOVEMENT_SPEED * ATTACK_MOVEMENT_MULTIPLIER;
                
                // collision detection for target
                
                // movement if no collision
                targetID.x -= x_adj;
                targetID.y += y_adj;
                
                // collision detection for me backing up
                
                // movement if no collision
                x += x_adj;
                y -= y_adj;
            }
            else {
                // free swing or hitting target
                var mult = swordID.speed_multiplier;
                x_adj = dcos(image_angle) * mult * MOVEMENT_SPEED;
                y_adj = dsin(image_angle) * mult * MOVEMENT_SPEED;
                // if collision with opponent
                if (place_meeting(x + x_adj, y - y_adj, targetID)) {
                    // if opponent can move back, push at half speed
                    x_adj *= ATTACK_PUSH_MULTIPLIER;
                    y_adj *= ATTACK_PUSH_MULTIPLIER;
                    with (targetID) {
                        // but only if space behind him is open
                        if (place_free(x + x_adj, y - y_adj)) {
                            // push him back!
                            x += x_adj;
                            y -= y_adj;
                        }
                        else {
                            // no one will move
                            x_adj = 0;
                            y_adj = 0;
                        }
                    }
                }
                x += x_adj;
                y -= y_adj;
            }
        }
        // always adjust sword position to player position
        swordID.x = x;
        swordID.y = y;
        swordID.image_angle = image_angle;
    }
    
    // player blocking
    if (block_button_pressed) {
        if (can_block) {
            can_attack = false;
            can_block = false;
            can_quickstep = false;
            block_held = true;
            block_lock = true;
            alarm[4] = BLOCK_RAISE_DELAY;
            alarm[5] = BLOCK_LOCK_DELAY;
        }
        else if (block_lock) {
            block_held = true;
        }
    }
    
    if (block_button_released) {
        block_held = false;
        if (!block_lock) {
            can_attack = true;
            blocking = false;
            can_block = true;
            // only enable quickstep if the timer is not set
            if (alarm[7] == -1) can_quickstep = true;
            invincible = false;
            image_index = NORMAL_IMAGE;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,16</point>
    <point>24,24</point>
  </PhysicsShapePoints>
</object>
